<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Linux文件系统之autofs, Hexo">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Linux文件系统之autofs | Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Linux文件系统之autofs</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">文件系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                Linux内核
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-03
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="autofs-how-it-works"><a href="#autofs-how-it-works" class="headerlink" title="autofs - how it works"></a>autofs - how it works</h1><h3 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h3><hr>
<p>The goal of autofs is to provide on-demand mounting and race free automatic unmounting of various other filesystems.  This provides two key advantages:</p>
<p>autofs 的目标是提供随需应变的挂载和各种其他文件系统的无争用自动卸载。这提供了两个关键优势:</p>
<ol>
<li><p>There is no need to delay boot until all filesystems that might be needed are mounted.  Processes that try to access those slow filesystems might be delayed but other processes can continue freely.  This is particularly important for network filesystems (e.g. NFS) or filesystems stored on media with a media-changing robot.<br>在挂载所有可能需要的文件系统之前，不需要延迟 boot。<br>试图访问这些慢速文件系统的进程可能会被延迟，但是其他进程可以自由地继续。<br>这对于网络文件系统(例如NFS)或存储在具有 media-changing 机器人的媒体上的文件系统尤其重要。</p>
</li>
<li><p>The names and locations of filesystems can be stored in a remote database and can change at any time.  The content in that data base at the time of access will be used to provide a target for the access.  The interpretation of names in the filesystem can even be programmatic rather than database-backed, allowing wildcards for example, and can vary based on the user who first accessed a name.<br>文件系统的名称和位置可以存储在远程数据库中，并且可以随时更改。访问的时候，数据库中的内容将用于提供<br>本次访问的目标。文件系统中名称的解释甚至可以是编程的，而不是数据库支持的，例如允许通配符，并且可以根据第一次访问名称的用户而变化。</p>
</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><hr>
<p>The “autofs4” filesystem module is only one part of an autofs system. There also needs to be a user-space program which looks up names and mounts filesystems.  This will often be the “automount” program, though other tools including “systemd” can make use of “autofs4”.This document describes only the kernel module and the interactions required with any user-space program.  Subsequent text refers to this as the “automount daemon” or simply “the daemon”.</p>
<p>“autofs4” 文件系统模块只是 autofs 系统的一部分。还需要一个用户空间程序来查找名称并安装文件系统。<br>这通常是 “automount” 程序，尽管包括 “systemd” 在内的其他工具可以使用 “autofs4”。<br>本文档只描述内核模块和与任何用户空间程序所需的交互。后续文本将其称为“automount daemon”，或者简单地称为“the daemon”。</p>
<p>“autofs4” is a Linux kernel module with provides the “autofs” filesystem type.  Several “autofs” filesystems can be mounted and they can each be managed separately, or all managed by the same daemon.</p>
<p>“autofs4” 是一个 Linux 内核模块，它提供了 “autofs” 文件系统类型。<br>可以挂载几个 “autofs” 文件系统，它们可以分别管理，也可以由同一个守护进程管理。</p>
<h4 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h4><hr>
<p>An autofs filesystem can contain 3 sorts of objects: directories, symbolic links and mount traps.  Mount traps are directories with extra properties as described in the next section.</p>
<p>autofs 文件系统可以包含三种对象:目录、符号链接和挂载陷阱。挂载陷阱是具有在下一节中描述的额外属性的目录。</p>
<p>Objects can only be created by the automount daemon: symlinks are created with a regular <code>symlink</code> system call, while directories and mount traps are created with <code>mkdir</code>.  The determination of whether a directory should be a mount trap or not is quite <em>ad hoc</em>, largely for historical reasons, and is determined in part by the <em>direct</em>/<em>indirect</em>/<em>offset</em> mount options, and the <em>maxproto</em> mount option.</p>
<p>对象只能由 automount 守护进程创建：使用常规的 <code>symlink</code> 系统调用创建符号链接，而使用 <code>mkdir</code> 创建目录和挂载陷阱。决定目录是否应该是挂载陷阱是非常特殊的，主要是由于历史原因，部分由 direct/indirect/offset 挂载选项和 maxproto 挂载选项决定。</p>
<p>If neither the <em>direct</em> or <em>offset</em> mount options are given (so the mount is considered to be <em>indirect</em>), then the root directory is always a regular directory, otherwise it is a mount trap when it is empty and a regular directory when not empty.  Note that <em>direct</em> and<br><em>offset</em> are treated identically so a concise summary is that the root directory is a mount trap only if the filesystem is mounted <em>direct</em> and the root is empty.</p>
<p>如果没有提供 direct 挂载选项或 offset 挂载选项(因此认为挂载是 indirect 挂载)，那么根目录始终是一个常规目录，否则在挂载为空时是一个挂载陷阱，在不为空时是一个常规目录。注意 direct 和 offset 的处理方式是相同的，因此简要的总结是，只有当文件系统 direct 挂载且根为空时，根目录才是挂载陷阱。</p>
<p>Directories created in the root directory are mount traps only if the filesystem is mounted  <em>indirect</em> and they are empty.</p>
<p>在根目录中创建的目录只有在文件系统是间接挂载的并且是空的情况下才是挂载陷阱。</p>
<p>Directories further down the tree depend on the <em>maxproto</em> mount option and particularly whether it is less than five or not. When <em>maxproto</em> is five, no directories further down the tree are ever mount traps, they are always regular directories.  When the <em>maxproto</em> is four (or three), these directories are mount traps precisely when they are empty.</p>
<p>树下的目录取决于 maxproto 挂载选项，特别是它是否小于 5。当 maxproto 为 5 时，树下没有任何目录是挂载陷阱，它们总是常规目录。当 maxproto 为 4(或3)时，这些目录恰好在它们为空时是挂载陷阱。</p>
<p>So: non-empty (i.e. non-leaf) directories are never mount traps. Empty directories are sometimes mount traps, and sometimes not depending on where in the tree they are (root, top level, or lower), the <em>maxproto</em>, and whether the mount was <em>indirect</em> or not.</p>
<p>因此:非空目录(即非叶子目录)永远不是挂载陷阱。空目录有时是挂载陷阱，有时不依赖于它们在树中的位置(根、顶层或底层)、maxproto，以及挂载是否间接。</p>
<h4 id="Mount-Traps"><a href="#Mount-Traps" class="headerlink" title="Mount Traps"></a>Mount Traps</h4><hr>
<p>A core element of the implementation of autofs is the Mount Traps which are provided by the Linux VFS.  Any directory provided by a filesystem can be designated as a trap.  This involves two separate features that work together to allow autofs to do its job.</p>
<p>autofs 实现的一个核心元素是 Linux VFS 提供的挂载陷阱。文件系统提供的任何目录都可以指定为陷阱。<br>这涉及到两个单独的特性，它们共同工作以允许 autofs 完成其工作。</p>
<p><strong>DCACHE_NEED_AUTOMOUNT</strong></p>
<p>If a dentry has the DCACHE_NEED_AUTOMOUNT flag set (which gets set if the inode has S_AUTOMOUNT set, or can be set directly) then it is (potentially) a mount trap.  Any access to this directory beyond a “<code>stat</code>“ will (normally) cause the <code>d_op-&gt;d_automount()</code> dentry operation to be called. The task of this method is to find the filesystem that should be mounted on the directory and to return it.  The VFS is responsible for actually mounting the root of this filesystem on the directory.</p>
<p>如果一个 dentry 设置了 DCACHE_NEED_AUTOMOUNT 标志(如果 inode 设置 S_AUTOMOUNT ，则设置该标志)，则它(可能)是一个挂载陷阱。除了“stat”之外，对该目录的任何访问(通常)都会调用 d_op-&gt;d_automount() 这个 dentry 操作。这个方法的任务是找到应该挂载在目录上的文件系统并返回它。VFS 负责在目录上实际挂载这个文件系统的根。</p>
<p>autofs doesn’t find the filesystem itself but sends a message to the automount daemon asking it to find and mount the filesystem.  The autofs <code>d_automount</code> method then waits for the daemon to report that everything is ready.  It will then return “<code>NULL</code>“ indicating that the<br>mount has already happened.  The VFS doesn’t try to mount anything but follows down the mount that is already there.</p>
<p>autofs 不会找到文件系统本身，而是向 automount 守护进程发送一条消息，要求它找到并挂载文件系统。然后 autofs 的 d_automount 方法等待守护进程报告一切就绪。然后，它将返回 “NULL”，指示 mount 已经发生了。VFS 不尝试挂载任何东西，而是跟随已经存在的挂载。</p>
<p>This functionality is sufficient for some users of mount traps such as NFS which creates traps so that mountpoints on the server can be reflected on the client.  However it is not sufficient for autofs.  As mounting onto a directory is considered to be “beyond a <code>stat</code>“, the automount daemon would not be able to mount a filesystem on the ‘trap’ directory without some way to avoid getting caught in the trap.  For that purpose there is another flag.</p>
<p>对于一些挂载陷阱（比如 NFS）的用户来说，这个功能已经足够了，NFS 创建陷阱，以便服务器上的挂载点可以反映到客户机上。然而，对于 autofs 这是不够的。由于在一个目录上进行挂载被认为是 “超出了 stat 的范围”，所以自动挂载守护进程无法挂载一个文件系统到 “trap” 目录上，除非采用某种方法避免陷入陷阱。为此目的，还有其他标志。</p>
<p><strong>DCACHE_MANAGE_TRANSIT</strong></p>
<p>If a dentry has DCACHE_MANAGE_TRANSIT set then two very different but related behaviors are invoked, both using the <code>d_op-&gt;d_manage()</code> dentry operation.</p>
<p>如果 dentry 具有 DCACHE_MANAGE_TRANSIT 集，那么将调用两个非常不同但相关的行为，都使用’ d_op-&gt;d_manage() ‘ 的 dentry 操作。</p>
<p>Firstly, before checking to see if any filesystem is mounted on the directory, d_manage() will be called with the <code>rcu_walk</code> parameter set to <code>false</code>.  It may return one of three things:</p>
<p>首先，在检查目录上是否安装了任何文件系统之前，将调用 d_manage()，并将 <code>rcu_walk</code> 参数设置为 <code>false</code>。它可能返回以下三种情况之一:</p>
<ul>
<li><p>A return value of zero indicates that there is nothing special about this dentry and normal checks for mounts and automounts should proceed.<br>返回值为 0 表示这个 dentry 没有什么特别之处，应该继续执行对挂载和自动挂载的常规检查。<br>autofs normally returns zero, but first waits for any expiry (automatic unmounting of the mounted filesystem) to complete.  This avoids races.<br>autofs 通常返回零，但首先等待任何过期(自动卸载已挂载的文件系统)完成。这可以避免竞争。</p>
</li>
<li><p>A return value of <code>-EISDIR</code> tells the VFS to ignore any mounts on the directory and to not consider calling <code>-&gt;d_automount()</code>. This effectively disables the <strong>DCACHE_NEED_AUTOMOUNT</strong> flag causing the directory not be a mount trap after all.<br>返回值 <code>-EISDIR</code> 告诉 VFS 忽略目录上的任何挂载，不要考虑调用 -&gt;d_automount()。这实际上禁用了 DCACHE_NEED_AUTOMOUNT 标志，从而使目录不是挂载陷阱。<br>autofs returns this if it detects that the process performing the lookup is the automount daemon and that the mount has been requested but has not yet completed.  How it determines this is discussed later.  This allows the automount daemon not to get caught in the mount trap.<br>如果 autofs 检测到执行查找的进程是 automount 守护进程，并且已经请求了挂载，但是还没有完成，那么它将返回 <code>-EISDIR</code>。稍后将讨论它如何确定这一点。这允许自动挂载守护进程不被挂载陷阱捕获。<br>There is a subtlety here.  It is possible that a second autofs filesystem can be mounted below the first and for both of them to be managed by the same daemon.  For the daemon to be able to mount something on the second it must be able to “walk” down past the first.  This means that d_manage cannot <em>always</em> return <code>-EISDIR</code> for the automount daemon.  It must only return it when a mount has been requested, but has not yet completed.<br>这里有一个微妙之处。第二个 autofs 文件系统可以挂载在第一个文件系统的下面，并且可以由同一个守护进程管理这两个文件系统。守护进程要能够在第二个上挂载某些东西，就必须能够向下通过第一个 autofs 文件系统。这意味着 d_manage 不能总是为自动加载守护进程返回 <code>-EISDIR</code>。它只能在请求挂载但尚未完成时返回。<br><code>d_manage</code> also returns <code>-EISDIR</code> if the dentry shouldn’t be a mount trap, either because it is a symbolic link or because it is not empty.<br>如果 dentry 不应该是挂载陷阱，这可能是因为它是一个符号链接，也可能是因为它不是空的。d_manage 也会返回 <code>-EISDIR</code>。</p>
</li>
<li><p>Any other negative value is treated as an error and returned to the caller.</p>
</li>
</ul>
<p>autofs can return<br>   -<code>-ENOENT</code> if the automount daemon failed to mount anything.<br>   -<code>-ENOMEM</code> if it ran out of memory.<br>   -<code>-EINTR</code> if a signal arrived while waiting for expiry to complete.<br>   -or any other error sent down by the automount daemon.</p>
<p>The second use case only occurs during an “RCU-walk” and so <code>rcu_walk</code><br>will be set.</p>
<p>第二种使用情况只会发生在 “RCU-walk” 中，所以 <code>rcu_walk</code> 参数被设置了。</p>
<p>An RCU-walk is a fast and lightweight process for walking down a filename path (i.e. it is like running on tip-toes).  RCU-walk cannot cope with all situations so when it finds a difficulty it falls back to “REF-walk”, which is slower but more robust.</p>
<p>RCU-walk 是一种快速并且轻量级的路径查找方式。 RCU-walk 不能处理所有的情况，所以当出现这<br>中情况时会回退到 REF-walk 方式，这是一种慢速但是可靠的方式。</p>
<p>RCU-walk will never call <code>-&gt;d_automount</code>; the filesystems must already be mounted or RCU-walk cannot handle the path. To determine if a mount-trap is safe for RCU-walk mode it calls <code>-&gt;d_manage()</code> with <code>rcu_walk</code> set to <code>true</code>.</p>
<p>RCU-walk 永远不会调用 <code>-&gt;d_automount</code>；当前文件系统必须已经被挂载了否则 RCU-walk 无法<br>处理当前路径。为了确定一个 mount-trap 是否对于 RCU-walk 安全，所以调用 <code>-&gt;d_manage()</code>并且参数 <code>rcu_walk</code> 设置为 <code>true</code>。</p>
<p>In this case <code>d_manage()</code> must avoid blocking and should avoid taking spinlocks if at all possible.  Its sole purpose is to determine if it would be safe to follow down into any mounted directory and the only reason that it might not be is if an expiry of the mount is underway.</p>
<p>在这种情况下，<code>d_manage()</code> 必须避免阻塞，并且应该尽可能避免使用自旋锁。<br>它的唯一目的是确定是否可以安全地跟踪到任何挂载目录，而不这样做的唯一原因是挂载的过期（卸载）正在进行中。</p>
<p>In the <code>rcu_walk</code> case, <code>d_manage()</code> cannot return -EISDIR to tell the VFS that this is a directory that doesn’t require d_automount.  If <code>rcu_walk</code> sees a dentry with DCACHE_NEED_AUTOMOUNT set but nothing mounted, it <em>will</em> fall back to REF-walk.  <code>d_manage()</code> cannot make the VFS remain in RCU-walk mode, but can only tell it to get out of RCU-walk mode by returning <code>-ECHILD</code>.</p>
<p>在 rcu_walk 的情况下，d_manage() 不能返回 <code>-EISDIR</code> 来告诉 VFS 这是一个不需要 d_automount 的目录。如果 rcu_walk 看到一个 dentry 设置了 <code>DCACHE_NEED_AUTOMOUNT</code>，但是没有安装任何东西，那么它将返回到 REF-walk。d_manage() 不能使 VFS 保持在 RCU-walk 模式，但只能通过返回 <code>-ECHILD</code> 告诉它退出 RCU-walk模式。</p>
<p>So <code>d_manage()</code>, when called with <code>rcu_walk</code> set, should either return -ECHILD if there is any reason to believe it is unsafe to end the mounted filesystem, and otherwise should return 0.</p>
<p>因此，当使用 rcu_walk 集调用 d_manage() 时，如果有任何理由认为结束已挂载的文件系统是不安全的，则应该返回 <code>-ECHILD</code>，否则应该返回0。</p>
<p>autofs will return <code>-ECHILD</code> if an expiry of the filesystem has been initiated or is being considered, otherwise it returns 0.</p>
<p>如果已经启动或正在进行的文件系统过期（卸载），autofs 将返回 <code>-ECHILD</code>，否则返回 0。</p>
<h4 id="Mountpoint-expiry"><a href="#Mountpoint-expiry" class="headerlink" title="Mountpoint expiry"></a>Mountpoint expiry</h4><hr>
<p>The VFS has a mechansim for automatically expiring unused mounts,much as it can expire any unused dentry information from the dcache.This is guided by the <code>MNT_SHRINKABLE</code> flag.  This  only applies to mounts that were created by <code>d_automount()</code> returning a filesystem to be mounted.  As autofs doesn’t return such a filesystem but leaves the mounting to the automount daemon, it must involve the automount daemon in unmounting as well.  This also means that autofs has more control of expiry.</p>
<p>VFS 有一个机制用来自动过期未使用的挂载，就像它可以过期 dcache 中未使用的 dentry 信息一样。这是由 <code>MNT_SHRINKABLE</code> 标志引导的。这只适用于 d_automount() 创建的挂载，它（函数）返回要挂载的文件系统。由于 autofs 不返回这样的文件系统，而是将挂载留给自动挂载守护进程，因此在卸载过程中也必须涉及自动挂载守护进程。这也意味着 autofs 对过期有更多的控制。</p>
<p>The VFS also supports “expiry” of mounts using the MNT_EXPIRE flag to the <code>umount</code> system call.  Unmounting with MNT_EXPIRE will fail unless a previous attempt had been made, and the filesystem has been inactive and untouched since that previous attempt.  autofs4 does not depend on this but has its own internal tracking of whether filesystems were recently used.  This allows individual names in the autofs directory to expire separately.</p>
<p>VFS 还支持 <code>umount</code> 系统调用使用 <code>MNT_EXPIRE</code> 标志来进行挂载“过期”。使用 <code>MNT_EXPIRE</code> 卸载将会失败，除非之前已经进行过尝试，并且该文件系统自上次尝试以来一直处于非活动状态且没有使用过。autofs4 不依赖于此，它有自己的内部跟踪，以确定最近是否使用了文件系统。这允许 autofs 目录中的各个名称单独过期。</p>
<p>With version 4 of the protocol, the automount daemon can try to unmount any filesystems mounted on the autofs filesystem or remove any symbolic links or empty directories any time it likes.  If the unmount or removal is successful the filesystem will be returned to the state it was before the mount or creation, so that any access of the name will trigger normal auto-mount processing.  In particlar, <code>rmdir</code> and <code>unlink</code> do not leave negative entries in the dcache as a normal filesystem would, so an attempt to access a recently-removed object is passed to autofs for handling.</p>
<p>使用协议的版本 4,automount 守护进程可以尝试卸载安装在 autofs 文件系统上的任何文件系统，或者删除任何符号链接或空目录。如果卸载或删除成功，文件系统将返回到挂载或创建之前的状态，这样对名称的任何访问都将触发正常的自动挂载处理。特别是，rmdir 和 unlink 不像普通文件系统那样在 dcache 中保留 <code>negative</code> 条目，因此访问 recently-removed 的对象的尝试被传递给 autofs 进行处理。</p>
<p>With version 5, this is not safe except for unmounting from top-level directories.  As lower-level directories are never mount traps, other processes will see an empty directory as soon as the filesystem is unmounted.  So it is generally safest to use the autofs expiry protocol described below.</p>
<p>对于版本 5，这是不安全的，除非是从 top-level 目录上卸载。由于 lower-level 目录从来不是挂载陷阱，所以一旦该文件系统被卸载了，其他进程将看到一个空目录。因此，通常使用下面描述的 autofs 过期协议是最安全的。</p>
<p>Normally the daemon only wants to remove entries which haven’t been used for a while.  For this purpose autofs maintains a “<code>last_used</code>“ time stamp on each directory or symlink.  For symlinks it genuinely does record the last time the symlink was “used” or followed to find out where it points to.  For directories the field is a slight misnomer.  It actually records the last time that autofs checked if the directory or one of its descendents was busy and found that it was.  This is just as useful and doesn’t require updating the field so<br>often.</p>
<p>通常，守护进程只想删除一段时间没有使用的条目。为此，autofs 在每个目录或符号链接上维护一个 “last_used” 时间戳。对于符号链接，它确实记录了符号链接最后一次被 “使用” 或被跟踪的时间，以找出它指向的位置。对于目录，该字段的名称稍有错误。实际上，它记录了 autofs 最后一次检查目录或它的一个派生目录是否繁忙，并发现它是繁忙的。这同样有用，不需要经常更新字段。</p>
<p>The daemon is able to ask autofs if anything is due to be expired, using an <code>ioctl</code> as discussed later.  For a <em>direct</em> mount, autofs considers if the entire mount-tree can be unmounted or not.  For an <em>indirect</em> mount, autofs considers each of the names in the top level directory to determine if any of those can be unmounted and cleaned up.</p>
<p>守护进程可以使用 ioctl 询问 autofs 是否有任何内容到期，稍后将讨论这个问题。<br>对于 <code>direct</code> 挂载，autofs 会考虑是否可以卸载整个挂载树。对于 <code>indirect</code> 挂载，autofs将考虑顶层目录中的每个名称，以确定是否可以卸载和清除其中的任何名称。</p>
<p>There is an option with indirect mounts to consider each of the leaves that has been mounted on instead of considering the top-level names. This is intended for compatability with version 4 of autofs and should be considered as deprecated.</p>
<p>还有一种方案：一个带有 <code>indirect</code> 的挂载，它考虑已挂载的每个叶子，而不是考虑 top-level 名称。这是为了与 autofs 的第 4 版兼容，应该被认为是不推荐的。</p>
<p>When autofs considers a directory it checks the <code>last_used</code> time and compares it with the “timeout” value set when the filesystem was mounted, though this check is ignored in some cases. It also checks if the directory or anything below it is in use.  For symbolic links, only the <code>last_used</code> time is ever considered.</p>
<p>当 autofs 考虑一个目录时，它会检查 “last_used” 时间，并将其与安装文件系统时设置的 “timeout” 值进行比较，不过在某些情况下会忽略这个检查。它还检查目录或目录下的任何内容是否正在使用。对于符号链接，只考虑 “last_used” 时间。</p>
<p>If both appear to support expiring the directory or symlink, an action is taken.</p>
<p>如果两者都支持目录或符号链接的过期，则将采取操作。</p>
<p>There are two ways to ask autofs to consider expiry.  The first is to use the <strong>AUTOFS_IOC_EXPIRE</strong> ioctl.  This only works for indirect mounts.  If it finds something in the root directory to expire it will return the name of that thing.  Once a name has been returned the automount daemon needs to unmount any filesystems mounted below the name normally.  As described above, this is unsafe for non-toplevel mounts in a version-5 autofs.  For this reason the current <code>automountd</code> does not use this ioctl.</p>
<p>有两种方法可以要求 autofs 考虑到期。第一种方法是使用 <code>AUTOFS_IOC_EXPIRE</code> ioctl。<br>这只适用于 <code>indirect</code> 挂载。如果它在根目录中发现要过期的内容，它将返回该内容的名称。<br>一旦返回了名称，automount 守护进程就需要卸载安装在名称下面的任何文件系统。如上所述，对于版本 5 中 autofs 的非 top-level 挂载，这是不安全的。由于这个原因，当前的 automountd 不使用这个 ioctl。</p>
<p>The second mechanism uses either the <strong>AUTOFS_DEV_IOCTL_EXPIRE_CMD</strong> or the <strong>AUTOFS_IOC_EXPIRE_MULTI</strong> ioctl.  This will work for both direct and indirect mounts.  If it selects an object to expire, it will notify the daemon using the notification mechanism described below.  This will block until the daemon acknowledges the expiry notification. This implies that the “<code>EXPIRE</code>“ ioctl must be sent from a different thread than the one which handles notification.</p>
<p>第二种机制使用 AUTOFS_DEV_IOCTL_EXPIRE_CMD 或 AUTOFS_IOC_EXPIRE_MULTI ioctl。<br>这将适用于 direct 和 indirect 挂载。如果选择一个对象来过期（卸载），它将使用下面描述的通知机制通知守护进程。这将阻塞，直到守护进程确认过期通知。这意味着 <code>EXPIRE</code> ioctl 必须从与处理通知的线程不同的线程发送。</p>
<p>While the ioctl is blocking, the entry is marked as “expiring” and <code>d_manage</code> will block until the daemon affirms that the unmount has completed (together with removing any directories that might have been necessary), or has been aborted.</p>
<p>当 ioctl 阻塞时，条目被标记为 “过期”，“d_manage” 将阻塞，直到守护进程确认卸载已经完成(以及删除了可能需要的任何目录)，或者已经中止。</p>
<h4 id="Communicating-with-autofs-detecting-the-daemon"><a href="#Communicating-with-autofs-detecting-the-daemon" class="headerlink" title="Communicating with autofs: detecting the daemon"></a>Communicating with autofs: detecting the daemon</h4><hr>
<p>There are several forms of communication between the automount daemon and the filesystem.  As we have already seen, the daemon can create and remove directories and symlinks using normal filesystem operations. autofs knows whether a process requesting some operation is the daemon or not based on its process-group id number (see getpgid(1)).</p>
<p>自动安装守护进程和文件系统之间有几种通信形式。正如我们已经看到的，守护进程可以使用普通的文件系统操作创建和删除目录和符号链接。autofs 根据进程组 id 号(参见getpgid(1))知道请求某种操作的进程是否是守护进程。</p>
<p>When an autofs filesystem it mounted， the pgid of the mounting processes is recorded unless the “pgrp=” option is given, in which case that number is recorded instead.  Any request arriving from a process in that process group is considered to come from the daemon. If the daemon ever has to be stopped and restarted， a new pgid can be provided through an ioctl as will be described below.</p>
<p>当一个 autofs 文件系统挂载了，挂载进程的 pgid 被记录，除非给出 “pgrp=” 选项，在这种情况下，将记录该编号。来自进程组中的进程的任何请求都被认为来自守护进程。如果守护进程必须停止并重新启动，可以通过 ioctl 提供一个新的 pgid，如下所述。</p>
<h4 id="Communicating-with-autofs-the-event-pipe"><a href="#Communicating-with-autofs-the-event-pipe" class="headerlink" title="Communicating with autofs: the event pipe"></a>Communicating with autofs: the event pipe</h4><hr>
<p>When an autofs filesystem is mounted, the ‘write’ end of a pipe must be passed using the ‘fd=’ mount option.  autofs will write notification messages to this pipe for the daemon to respond to. For version 5, the format of the message is:<br>当安装 autofs 文件系统时，必须使用 ‘fd=’ mount 选项传递给管道的’写’端。autofs 将向这个管道写入通知消息，以便守护进程作出响应。<br>对于版本5，消息的格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> autofs_v5_packet &#123;</span><br><span class="line">        <span class="keyword">int</span> proto_version;                <span class="comment">/* Protocol version */</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">type</span>;                        <span class="comment">/* Type of packet */</span></span><br><span class="line">        autofs_wqt_t wait_queue_token;</span><br><span class="line">        __u32 dev;</span><br><span class="line">        __u64 ino;</span><br><span class="line">        __u32 uid;</span><br><span class="line">        __u32 gid;</span><br><span class="line">        __u32 pid;</span><br><span class="line">        __u32 tgid;</span><br><span class="line">        __u32 <span class="built_in">len</span>;</span><br><span class="line">        char name[NAME_MAX+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>where the type is one of</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autofs_ptype_missing_indirect</span><br><span class="line">autofs_ptype_expire_indirect</span><br><span class="line">autofs_ptype_missing_direct</span><br><span class="line">autofs_ptype_expire_direct</span><br></pre></td></tr></table></figure>
<p>so messages can indicate that a name is missing (something tried to access it but it isn’t there) or that it has been selected for expiry.</p>
<p>因此，消息可以指示缺少了一个名称(试图访问该名称但它不在那里)，或者它已被选择为过期。</p>
<p>The pipe will be set to “packet mode” (equivalent to passing <code>O_DIRECT</code>) to <em>pipe2(2)</em> so that a read from the pipe will return at most one packet, and any unread portion of a packet will be discarded.</p>
<p>管道将被设置为 “packet mode”(相当于传递了 “O_DIRECT” 给 _pipe2(2)_），以便从管道中读取的数据最多返回一个包，而包中任何未读取的部分将被丢弃。</p>
<p>The <code>wait_queue_token</code> is a unique number which can identify a particular request to be acknowledged.  When a message is sent over the pipe the affected dentry is marked as either “active” or “expiring” and other accesses to it block until the message is acknowledged using one of the ioctls below and the relevant<br><code>wait_queue_token</code>.</p>
<p><code>wait_queue_token</code> 是一个惟一的数字，它可以标识要确认的特定请求。当消息通过管道发送时，受影响的 dentry 被标记为 “active” 或“expiring”，对它的其他访问将被阻塞，直到消息被确认为止。使用下面某一个 ioctls 以及相关的 <code>wait_queue_token</code>。</p>
<h4 id="Communicating-with-autofs-root-directory-ioctls"><a href="#Communicating-with-autofs-root-directory-ioctls" class="headerlink" title="Communicating with autofs: root directory ioctls"></a>Communicating with autofs: root directory ioctls</h4><hr>
<p>The root directory of an autofs filesystem will respond to a number of<br>ioctls.   The process issuing the ioctl must have the CAP_SYS_ADMIN<br>capability, or must be the automount daemon.</p>
<p>The available ioctl commands are:</p>
<ul>
<li><p><strong>AUTOFS_IOC_READY</strong>: a notification has been handled.  The argument<br>to the ioctl command is the “wait_queue_token” number<br>corresponding to the notification being acknowledged.</p>
</li>
<li><p><strong>AUTOFS_IOC_FAIL</strong>: similar to above, but indicates failure with<br>the error code <code>ENOENT</code>.</p>
</li>
<li><p><strong>AUTOFS_IOC_CATATONIC</strong>: Causes the autofs to enter “catatonic”<br>mode meaning that it stops sending notifications to the daemon.<br>This mode is also entered if a write to the pipe fails.</p>
</li>
<li><p><strong>AUTOFS_IOC_PROTOVER</strong>:  This returns the protocol version in use.</p>
</li>
<li><p><strong>AUTOFS_IOC_PROTOSUBVER</strong>: Returns the protocol sub-version which<br>is really a version number for the implementation.  It is<br>currently 2.</p>
</li>
<li><p><strong>AUTOFS_IOC_SETTIMEOUT</strong>:  This passes a pointer to an unsigned<br>long.  The value is used to set the timeout for expiry, and<br>the current timeout value is stored back through the pointer.</p>
</li>
<li><p><strong>AUTOFS_IOC_ASKUMOUNT</strong>:  Returns, in the pointed-to <code>int</code>, 1 if<br>the filesystem could be unmounted.  This is only a hint as<br>the situation could change at any instant.  This call can be<br>use to avoid a more expensive full unmount attempt.</p>
</li>
<li><p><strong>AUTOFS_IOC_EXPIRE</strong>: as described above, this asks if there is<br>anything suitable to expire.  A pointer to a packet:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> autofs_packet_expire_multi &#123;</span><br><span class="line">        <span class="keyword">int</span> proto_version;              <span class="comment">/* Protocol version */</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">type</span>;                       <span class="comment">/* Type of packet */</span></span><br><span class="line">        autofs_wqt_t wait_queue_token;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">len</span>;</span><br><span class="line">        char name[NAME_MAX+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> is required.  This is filled in with the name of something<br> that can be unmounted or removed.  If nothing can be expired,<br> <code>errno</code> is set to <code>EAGAIN</code>.  Even though a <code>wait_queue_token</code><br> is present in the structure, no “wait queue” is established<br> and no acknowledgment is needed.</p>
</li>
<li><p><strong>AUTOFS_IOC_EXPIRE_MULTI</strong>:  This is similar to<br> <strong>AUTOFS_IOC_EXPIRE</strong> except that it causes notification to be<br> sent to the daemon, and it blocks until the daemon acknowledges.<br> The argument is an integer which can contain two different flags.</p>
</li>
<li><p><strong>AUTOFS_EXP_IMMEDIATE</strong> causes <code>last_used</code> time to be ignored<br> and objects are expired if the are not in use.</p>
</li>
<li><p><strong>AUTOFS_EXP_LEAVES</strong> will select a leaf rather than a top-level<br> name to expire.  This is only safe when <em>maxproto</em> is 4.</p>
</li>
</ul>
<h2 id="Communicating-with-autofs-char-device-ioctls"><a href="#Communicating-with-autofs-char-device-ioctls" class="headerlink" title="Communicating with autofs: char-device ioctls"></a>Communicating with autofs: char-device ioctls</h2><p>It is not always possible to open the root of an autofs filesystem,<br>particularly a <em>direct</em> mounted filesystem.  If the automount daemon<br>is restarted there is no way for it to regain control of existing<br>mounts using any of the above communication channels.  To address this<br>need there is a “miscellaneous” character device (major 10, minor 235)<br>which can be used to communicate directly with the autofs filesystem.<br>It requires CAP_SYS_ADMIN for access.</p>
<p>The <code>ioctl</code>s that can be used on this device are described in a separate<br>document <code>autofs4-mount-control.txt</code>, and are summarized briefly here.<br>Each ioctl is passed a pointer to an <code>autofs_dev_ioctl</code> structure:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> autofs_dev_ioctl &#123;</span><br><span class="line">        __u32 ver_major;</span><br><span class="line">        __u32 ver_minor;</span><br><span class="line">        __u32 size;             <span class="comment">/* total size of data passed in</span></span><br><span class="line"><span class="comment">                                 * including this struct */</span></span><br><span class="line">        __s32 ioctlfd;          <span class="comment">/* automount command fd */</span></span><br><span class="line"></span><br><span class="line">        __u32 arg1;             <span class="comment">/* Command parameters */</span></span><br><span class="line">        __u32 arg2;</span><br><span class="line"></span><br><span class="line">        char path[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For the <strong>OPEN_MOUNT</strong> and <strong>IS_MOUNTPOINT</strong> commands, the target<br>filesystem is identified by the <code>path</code>.  All other commands identify<br>the filesystem by the <code>ioctlfd</code> which is a file descriptor open on the<br>root, and which can be returned by <strong>OPEN_MOUNT</strong>.</p>
<p>The <code>ver_major</code> and <code>ver_minor</code> are in/out parameters which check that<br>the requested version is supported, and report the maximum version<br>that the kernel module can support.</p>
<p>Commands are:</p>
<ul>
<li><p><strong>AUTOFS_DEV_IOCTL_VERSION_CMD</strong>: does nothing, except validate and<br>set version numbers.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_OPENMOUNT_CMD</strong>: return an open file descriptor<br>on the root of an autofs filesystem.  The filesystem is identified<br>by name and device number, which is stored in <code>arg1</code>.  Device<br>numbers for existing filesystems can be found in<br><code>/proc/self/mountinfo</code>.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD</strong>: same as <code>close(ioctlfd)</code>.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_SETPIPEFD_CMD</strong>: if the  filesystem is in<br>catatonic mode, this can provide the write end of a new pipe<br>in <code>arg1</code> to re-establish communication with a daemon.  The<br>process group of the calling process is used to identify the<br>daemon.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_REQUESTER_CMD</strong>: <code>path</code> should be a<br>name within the filesystem that has been auto-mounted on.<br>arg1 is the dev number of the underlying autofs.  On successful<br>return, <code>arg1</code> and <code>arg2</code> will be the UID and GID of the process<br>which triggered that mount.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD</strong>: Check if path is a<br>mountpoint of a particular type - see separate documentation for<br>details.</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_PROTOVER_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_READY_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_FAIL_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_CATATONIC_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_TIMEOUT_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_EXPIRE_CMD</strong>:</p>
</li>
<li><p><strong>AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD</strong>:  These all have the same<br>function as the similarly named <strong>AUTOFS_IOC</strong> ioctls, except<br>that <strong>FAIL</strong> can be given an explicit error number in <code>arg1</code><br>instead of assuming <code>ENOENT</code>, and this <strong>EXPIRE</strong> command<br>corresponds to <strong>AUTOFS_IOC_EXPIRE_MULTI</strong>.</p>
</li>
</ul>
<h2 id="Catatonic-mode"><a href="#Catatonic-mode" class="headerlink" title="Catatonic mode"></a>Catatonic mode</h2><p>As mentioned, an autofs mount can enter “catatonic” mode.  This<br>happens if a write to the notification pipe fails, or if it is<br>explicitly requested by an <code>ioctl</code>.</p>
<p>When entering catatonic mode, the pipe is closed and any pending<br>notifications are acknowledged with the error <code>ENOENT</code>.</p>
<p>Once in catatonic mode attempts to access non-existing names will<br>result in <code>ENOENT</code> while attempts to access existing directories will<br>be treated in the same way as if they came from the daemon, so mount<br>traps will not fire.</p>
<p>When the filesystem is mounted a <em>uid</em> and <em>gid</em> can be given which<br>set the ownership of directories and symbolic links.  When the<br>filesystem is in catatonic mode, any process with a matching UID can<br>create directories or symlinks in the root directory, but not in other<br>directories.</p>
<p>Catatonic mode can only be left via the<br><strong>AUTOFS_DEV_IOCTL_OPENMOUNT_CMD</strong> ioctl on the <code>/dev/autofs</code>.</p>
<h2 id="autofs-name-spaces-and-shared-mounts"><a href="#autofs-name-spaces-and-shared-mounts" class="headerlink" title="autofs, name spaces, and shared mounts"></a>autofs, name spaces, and shared mounts</h2><p>With bind mounts and name spaces it is possible for an autofs<br>filesystem to appear at multiple places in one or more filesystem<br>name spaces.  For this to work sensibly, the autofs filesystem should<br>always be mounted “shared”. e.g.</p>
<blockquote>
<p><code>mount --make-shared /autofs/mount/point</code></p>
</blockquote>
<p>The automount daemon is only able to mange a single mount location for<br>an autofs filesystem and if mounts on that are not ‘shared’, other<br>locations will not behave as expected.  In particular access to those<br>other locations will likely result in the <code>ELOOP</code> error</p>
<blockquote>
<p>Too many levels of symbolic links</p>
</blockquote>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LiangLiang.li</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://woitaylor.github.io.git/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bautofs/">https://woitaylor.github.io.git/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bautofs/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LiangLiang.li</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">文件系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/04/Linxu-Open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AF%87%E4%B8%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="Linxu-Open系统调用篇（三）">
                        
                        <span class="card-title">Linxu-Open系统调用篇（三）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            “..”处理函数 handle_dots123456789101112static inline int handle_dots(struct nameidata * nd, int type)&#123;	if (type == LAST
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-09-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                    Linux内核
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">文件系统</span>
                    </a>
                    
                    <a href="/tags/open/">
                        <span class="chip bg-color">open</span>
                    </a>
                    
                    <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
                        <span class="chip bg-color">系统调用</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Linux文件系统挂载">
                        
                        <span class="card-title">Linux文件系统挂载</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            挂载文件系统虚拟文件系统在内存中把目录组织为一棵树一个文件系统，只有挂载到内存中目录树的一个目录下，进程才能访问这个文件系统。管理员可以执行命令 mount-t- fstype[--o options] device dir，把存储设备 d
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-09-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                    Linux内核
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">文件系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">LiangLiang.li</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
