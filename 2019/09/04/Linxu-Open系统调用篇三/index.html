<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Linxu-Open系统调用篇（三）, Hexo">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Linxu-Open系统调用篇（三） | Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Linxu-Open系统调用篇（三）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">文件系统</span>
                            </a>
                        
                            <a href="/tags/open/">
                                <span class="chip bg-color">open</span>
                            </a>
                        
                            <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
                                <span class="chip bg-color">系统调用</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                Linux内核
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-04
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="“-”处理函数-handle-dots"><a href="#“-”处理函数-handle-dots" class="headerlink" title="“..”处理函数 handle_dots"></a>“..”处理函数 handle_dots</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="keyword">int</span> handle_dots(<span class="keyword">struct</span> nameidata * nd, <span class="keyword">int</span> <span class="keyword">type</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">type</span> == LAST_DOTDOT) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">			<span class="keyword">return</span> follow_dotdot_rcu(nd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> follow_dotdot(nd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是针对 “..” 做处理；如果是 “.” 的话那就就代表的是当前路径，直接返回就好了。前面说过 <code>do_filp_open</code> 会首先使用 RCU 策略进行操作，如果不行再用普通策略。这里就可以看出只有 RCU 失败才会返回 <code>-ECHILD</code> 以启动普通策略。但是大家有没有发现，这里并没有对 <code>follow_dotdot(rcu)</code> 的返回值进行检查，为什么？这是因为 “..” 出现在路径里就表示要向“上”走一层，也就是要走到父目录里面去，而父目录一定是存在内存中而且对于当前的进程来说一定也是合法的，否则在读取父目录的时候就已经出错了。接着我们就来 “跟随 ..”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">int</span> follow_dotdot_rcu(<span class="keyword">struct</span> nameidata * nd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> inode * inode = nd-&gt;inode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 nd 的根目录（nd.root）</span></span><br><span class="line">	<span class="keyword">if</span> (!nd-&gt;root.mnt)</span><br><span class="line">		set_root_rcu(nd);</span><br><span class="line"></span><br><span class="line">	while (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果当前路径就是预设根目录的话，就什么也不做直接跳出循环（</span></span><br><span class="line"><span class="comment">        都已经到根目录了不退出还等啥呢，大家可以在根目录试试这个命令“cd ../../”，看看有什么效果）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">if</span> (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前路径不是预设根目录，但也不是当前文件系统的根目录，</span></span><br><span class="line">        <span class="comment">// 那么向上走一层也是很简单的事，直接将父目录项拿过来就是了。</span></span><br><span class="line">		<span class="keyword">if</span> (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) &#123;</span><br><span class="line">			<span class="keyword">struct</span> dentry * old = nd-&gt;path.dentry;</span><br><span class="line">            <span class="comment">// 获得父目录</span></span><br><span class="line">			<span class="keyword">struct</span> dentry * parent = old-&gt;d_parent;</span><br><span class="line">			unsigned seq;</span><br><span class="line"></span><br><span class="line">			inode = parent-&gt;d_inode;</span><br><span class="line">			seq = read_seqcount_begin(&amp;parent-&gt;d_seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前的 dentry 发生了改变（其他进程修改或者删除），就返回错误。</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(read_seqcount_retry(&amp;old-&gt;d_seq, nd-&gt;seq)))</span><br><span class="line">				<span class="keyword">return</span> - ECHILD;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 设置当前路径为它的父目录。</span></span><br><span class="line">			nd-&gt;path.dentry = parent;</span><br><span class="line">			nd-&gt;seq = seq;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//path_connected - Verify that a path-&gt;dentry is below path-&gt;mnt.mnt_root</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!path_connected(&amp;nd-&gt;path)))</span><br><span class="line">				<span class="keyword">return</span> - ENOENT;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//到最后，当前路径一定是某个文件系统的根目录，往上走有可能就会走到另一个文件系统里去了。</span></span><br><span class="line">			<span class="keyword">struct</span> mount * mnt = real_mount(nd-&gt;path.mnt);</span><br><span class="line">      		<span class="comment">// 获取父挂载描述符（mount)。</span></span><br><span class="line">			<span class="keyword">struct</span> mount * mparent = mnt-&gt;mnt_parent;</span><br><span class="line">      		<span class="comment">// 获取挂载点。</span></span><br><span class="line">			<span class="keyword">struct</span> dentry * mountpoint = mnt-&gt;mnt_mountpoint;</span><br><span class="line">      		<span class="comment">// 获取挂载点的索引节点。</span></span><br><span class="line">			<span class="keyword">struct</span> inode * inode2 = mountpoint-&gt;d_inode;</span><br><span class="line">      		<span class="comment">// 获取 mountpoint-&gt;d_seq 序列锁的初始 count，用于多线程竞争。</span></span><br><span class="line">			unsigned seq = read_seqcount_begin(&amp;mountpoint-&gt;d_seq);</span><br><span class="line">      		<span class="comment">// 使用全局序列锁 mount_lock 检查当前路径分量有没有发生改变。如果有，返回 -ECHILD</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))</span><br><span class="line">				<span class="keyword">return</span> - ECHILD;</span><br><span class="line">      		<span class="comment">// 当前的文件系统是不是根文件系统，也就是 rootfs 文件系统。如果是则返回。</span></span><br><span class="line">			<span class="keyword">if</span> (&amp;mparent-&gt;mnt == nd-&gt;path.mnt)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 现在我们知道当前路径分量处于挂载点 */</span></span><br><span class="line">			nd-&gt;path.dentry = mountpoint;</span><br><span class="line">      		<span class="comment">// 设置为父挂载描述符。</span></span><br><span class="line">			nd-&gt;path.mnt = &amp;mparent-&gt;mnt;</span><br><span class="line">			inode = inode2;</span><br><span class="line">			nd-&gt;seq = seq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// d_mountpoint 函数检查 dentry 的 d_flags 有没有设置 DCACHE_MOUNTED，即检查该目录</span></span><br><span class="line">    <span class="comment">// 是否是挂载点。</span></span><br><span class="line">	while (unlikely(d_mountpoint(nd-&gt;path.dentry))) &#123;<span class="comment">// 如果是挂载点</span></span><br><span class="line">		<span class="keyword">struct</span> mount * mounted;</span><br><span class="line">        <span class="comment">// 在散列表中通过&#123;父挂载描述符，名称&#125;方式查找对应的挂载描述符。</span></span><br><span class="line">		mounted = __lookup_mnt(nd-&gt;path.mnt, nd-&gt;path.dentry);</span><br><span class="line">        <span class="comment">// 检查期间挂载点是否有改变。</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))</span><br><span class="line">			<span class="keyword">return</span> - ECHILD;</span><br><span class="line">        <span class="comment">// 如果没有在散列表中找到，退出循环。</span></span><br><span class="line">		<span class="keyword">if</span> (!mounted)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 现在更新为找到的文件系统的挂载描述符。</span></span><br><span class="line">		nd-&gt;path.mnt = &amp;mounted-&gt;mnt;</span><br><span class="line">        <span class="comment">// 现在更新为找到的文件系统的根目录，接着继续循环，如果根目录也为挂载点</span></span><br><span class="line">        <span class="comment">// 那么继续找，直到找到一个根目录不为挂载点的文件系统。</span></span><br><span class="line">		nd-&gt;path.dentry = mounted-&gt;mnt.mnt_root;</span><br><span class="line">		inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">		nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nd-&gt;inode = inode;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set_root_rcu(nd);</code> 首先设置 nd 的根目录（nd.root），还记得我们在哪里设置过这个成员么？没错，在 <code>path_init</code> 函数里，如果是绝对路径的话就会把这个 nd.root 设置成当前进程的根目录（其实还可以在 <code>do_file_open_root</code> 里预设这个值，所以为了和系统根目录区分，我们称 nd.root 为预设根目录），但如果是相对路径的话，就没有对 nd.root 进行初始化。为啥要分两步走呢？还是因为效率问题，任何一个目录都是一种资源，根目录也不例外，要获取某种资源必定会有一定的系统开销（在这里就是顺序锁），况且很有可能辛辛苦苦获得了这个根目录资源却根本就用不上，造成无端的浪费，所以 Kernel 本着能不用就不用的原则不到万不得已绝不轻易占用系统资源。现在的情况是路径中出现了“..”，就说明需要向上走一层，也就有可能会访问根目录，所以现在正是获取根目录的时候。<br>接下来是一个 <code>while</code> 循环，这时就分了三种情况：</p>
<ol>
<li>当前目录就是前面获取的预设根目录，那么什么都不做，退出。</li>
<li>当前目录不是预设根目录，但也不是当前文件系统的根目录，那么直接获取当前目录的父目录即可。</li>
<li>当前目录不是预设根目录，但它是当前文件系统的根目录，那么往上走就会跑到别的文件系统。</li>
</ol>
<p>对于第三种情况，需要了解文件系统挂载相关知识，可以参考链接：<br><a href="https://woitaylor.github.io/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/" target="_blank" rel="noopener">Linux挂载文件系统</a></p>
<p>这里结合图片来解释该种情况：<br>这是一个关于 mount（挂载）的故事。在 Kernel 世界里，挂载是一项很了不起的特性，它可以将不同类型的文件系统组合成一个有机的整体，从使用者角度来看不同的文件系统并没有什么区别，那么 Kernel 是怎么做到呢？首先，Kernel 会为每个文件系统准备一个 mount 结构，然后再把这个结构加入到 vfs 这颗大树上就好了。这么一个小小的 mount 结构就这么神奇？请看图，一个 mount 中有三个很重要的成员，他们分别指向父 mount 结构（5）、本文件系统自己的根目录（6）和本文件系统的挂载点（7），前两个很好理解，那么挂载点是什么呢？简单地说挂载点就是父级文件系统的某个目录，一旦将某个文件系统挂载到某个目录上，这个目录就成了该文件系统的根目录了。并且该目录的标志位 DCACHE_MOUNTED 将被置位，这将表明这个目录已经是一个挂载点了，如果要访问这个目录的话就要顺着 mount 结构访问另一个文件系统了，原来的内容将变得不可访问（被隐藏了）。<br><img src="https://pic.superbed.cn/item/5d6f6126451253d1781987a0.png" alt=""></p>
<p>现在我们从图的左边讲起，带你一窥 mount 的风采。一个进程有一个叫 root 的 path 结构，它就是本进程的根目录（大多数情况下它就是系统根目录），root 中两个成员分别指向某个文件系统的 mount 结构（其实是指向类型为 vfsmoust 的 mount.mnt 但这样理解没问题）（1）和该文件系统的根目录（2），这个文件系统就是所谓根文件系统（在图中就是 rootfs）。由于它是根文件系统，所以它的父 mount 结构就是它自己（12）它的挂载点就是它自己的根目录（4）。但是 rootfs 只是一个临时的根文件系统，在 Kernel 的启动过程中加载完 rootfs 之后会紧接着解压缩 initramfs 到 rootfs 中，这里面包括了驱动以及加载真正的根文件系统的工具，Kernel 通过加载这些驱动、使用这些工具实现了挂载真正的根文件系统。之后 rootfs 将推出历史舞台，但作为文件系统的总根 rootfs 并不会被卸载。图中 fs1 就是所谓的真正的根文件系统，Kernel 把它挂载到了 rootfs 的根目录上（7），并且将它的父 mount 结构指向了 rootfs（5）。这时访问根目录的话就会直接访问到 fs1 的根目录，而 rootfs 就好像不存在了一样。<br>再看 fs1，他有一个子目录 “mnt/”，以及 “mnt/” 的子目录 “a”，此时路径 “/mnt/a/” 是可访问的。但现在我们还有另一个文件系统 fs2，我们把它挂载到“/mnt/”上会发生什么呢？首先 fs2 的父 mount 将指向 fs1（8），然后 fs2 的挂载点将指向 “/mnt/” 的dentry（9），同时 “mnt/” dentry 的 d_flags 的 <code>DCACHE_MOUNTED</code> 将被置位。此时路径 “/mnt/a/” 就不可访问了，取而代之的是 “/mnt/b/”。本着不怕麻烦的精神我们再折腾一下，把 fs3 也挂载到 “/mnt/” 上，这时和挂载 fs2 一样父 mount 将指向 fs2（10），但是挂载点应该指向哪里呢？答案是 fs2 的根目录（11）。这时“/mnt/b/”也消失了，我们只能看见“/mnt/c”了。这样整个结构就形成了一个挂载的序列，最后挂载的在序列末尾，Kernel 可以很容易的通过这个序列找到最初的挂载点和最终的文件系统。（图中几个 “/mnt” 目录的 dentry 是同一个 dentry，图中画了几个是为了方便作图。）<br>在顺序查找的情景下，当遇到一个目录时 Kernel 会判断这个目录是不是挂载点（检查 <code>DCACHE_MOUNTED</code> 标志位），如果是就要找到挂载到这个目录的文件系统，继而找到该文件系统的根目录，然后在判断这个根目录是不是挂载点，如果是那就再往下找直到某个文件系统的根目录不再是挂载点。反向查找也和顺序查找类似，把上面代码放这里，方便看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">int</span> follow_dotdot_rcu(<span class="keyword">struct</span> nameidata * nd)</span><br><span class="line">&#123;</span><br><span class="line">  while(<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//到最后，当前路径一定是某个文件系统的根目录，往上走有可能就会走到另一个文件系统里去了。</span></span><br><span class="line">      <span class="keyword">struct</span> mount * mnt = real_mount(nd-&gt;path.mnt);</span><br><span class="line">      <span class="comment">// 获取父挂载描述符（mount)。</span></span><br><span class="line">      <span class="keyword">struct</span> mount * mparent = mnt-&gt;mnt_parent;</span><br><span class="line">      <span class="comment">// 获取挂载点。</span></span><br><span class="line">      <span class="keyword">struct</span> dentry * mountpoint = mnt-&gt;mnt_mountpoint;</span><br><span class="line">      <span class="comment">// 获取挂载点的索引节点。</span></span><br><span class="line">      <span class="keyword">struct</span> inode * inode2 = mountpoint-&gt;d_inode;</span><br><span class="line">      <span class="comment">// 获取 mountpoint-&gt;d_seq 序列锁的初始 count，用于多线程竞争。</span></span><br><span class="line">      unsigned seq = read_seqcount_begin(&amp;mountpoint-&gt;d_seq);</span><br><span class="line">      <span class="comment">// 使用全局序列锁 mount_lock 检查当前路径分量有没有发生改变。如果有，返回 -ECHILD</span></span><br><span class="line">      <span class="keyword">if</span> (unlikely(read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))</span><br><span class="line">        <span class="keyword">return</span> - ECHILD;</span><br><span class="line">      <span class="comment">// 当前的文件系统是不是根文件系统，如果是则返回。</span></span><br><span class="line">      <span class="keyword">if</span> (&amp;mparent-&gt;mnt == nd-&gt;path.mnt)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      现在我们知道当前路径分量设置为挂载点目录，但仅仅这样做是不够的，</span></span><br><span class="line"><span class="comment">      因为很有可能现在的这个目录也是该文件系统的根目录，所以继续循环。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      nd-&gt;path.dentry = mountpoint;</span><br><span class="line">      <span class="comment">// 设置为父挂载描述符。</span></span><br><span class="line">      nd-&gt;path.mnt = &amp;mparent-&gt;mnt;</span><br><span class="line">      inode = inode2;</span><br><span class="line">      nd-&gt;seq = seq;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当跳出这个 <code>while(1)</code> 循环时我们已经站在某个目录上了，一般来说这个目录就是我们想要的目标，而不会是一个挂载点，但也有例外。请看 <code>while(1)</code> 循环中第一个 if 和最后那个 else 中的那个 if，想必大家已经发现了，当遇到（预设）根目录的时候会直接退出循环，而这时我们的位置就相当于站在图中 rootfs 的根目录上，这显然不是我们想要的，我们想要站在 fs1 的根目录上。这就需要接下来的循环，再顺着 mount 结构往下走。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static <span class="keyword">int</span> follow_dotdot_rcu(<span class="keyword">struct</span> nameidata * nd)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// d_mountpoint 函数检查 dentry 的 d_flags 有没有设置 DCACHE_MOUNTED，即检查该目录</span></span><br><span class="line">    <span class="comment">// 是否是挂载点。</span></span><br><span class="line">    while (unlikely(d_mountpoint(nd-&gt;path.dentry))) &#123;<span class="comment">// 如果是挂载点</span></span><br><span class="line">    <span class="keyword">struct</span> mount * mounted;</span><br><span class="line">    <span class="comment">// 在散列表中通过&#123;父挂载描述符，名称&#125;方式查找对应的挂载描述符。</span></span><br><span class="line">    mounted = __lookup_mnt(nd-&gt;path.mnt, nd-&gt;path.dentry);</span><br><span class="line">    <span class="comment">// 检查期间挂载点是否有改变。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))</span><br><span class="line">      <span class="keyword">return</span> - ECHILD;</span><br><span class="line">    <span class="comment">// 如果没有在散列表中找到，退出循环。</span></span><br><span class="line">    <span class="keyword">if</span> (!mounted)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 现在更新为找到的文件系统的挂载描述符。</span></span><br><span class="line">    nd-&gt;path.mnt = &amp;mounted-&gt;mnt;</span><br><span class="line">    <span class="comment">// 现在更新为找到的文件系统的根目录，接着继续循环，如果根目录也为挂载点</span></span><br><span class="line">    <span class="comment">// 那么继续找，直到找到一个根目录不为挂载点的文件系统。</span></span><br><span class="line">    nd-&gt;path.dentry = mounted-&gt;mnt.mnt_root;</span><br><span class="line">    inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">    nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline <span class="keyword">bool</span> d_mountpoint(<span class="keyword">const</span> <span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> dentry-&gt;d_flags &amp; DCACHE_MOUNTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>d_mountpoint()</code> 就是检查标志位 <code>DCACHE_MOUNTED</code>，然后在某个散列表中查找属于这个挂载点的 mount 结构，如果找到了（如果某个目录既是挂载点但又没有任何文件系统挂载在上面那就说明这个目录可能拥有自动挂载的属性），就往下走一层，走到挂载文件系统的根目录上，然后再回到 <code>while (unlikely(d_mountpoint(nd-&gt;path.dentry)))</code> 再判断、查找、向下走，周而复始直到某个非挂载点。<br>对于非 RCU 模式的 <code>follow_dotdot()</code> 函数，流程是一样的，只不过同步的手段不一样而已，这里就不描述了。</p>
<h4 id="挂载描述符缓存介绍"><a href="#挂载描述符缓存介绍" class="headerlink" title="挂载描述符缓存介绍"></a>挂载描述符缓存介绍</h4><p>这里提下 <code>__lookup_mnt</code> 挂载描述符查找函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * find the first mount at @dentry on vfsmount @mnt.</span></span><br><span class="line"><span class="comment"> * call under rcu_read_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> mount *__lookup_mnt(<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> hlist_head *head = m_hash(mnt, dentry);</span><br><span class="line">	<span class="keyword">struct</span> mount *p;</span><br><span class="line">  	<span class="comment">// 遍历哈希表。</span></span><br><span class="line">	hlist_for_each_entry_rcu(p, head, mnt_hash)</span><br><span class="line">		<span class="keyword">if</span> (&amp;p-&gt;mnt_parent-&gt;mnt == mnt &amp;&amp; p-&gt;mnt_mountpoint == dentry)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_for_each_entry_rcu - iterate over rcu list of given type</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the hlist_node within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This list-traversal primitive may safely run concurrently with</span></span><br><span class="line"><span class="comment"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span></span><br><span class="line"><span class="comment"> * as long as the traversal is guarded by rcu_read_lock().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define hlist_for_each_entry_rcu(pos, head, member)			\</span><br><span class="line">	<span class="keyword">for</span> (pos = hlist_entry_safe (rcu_dereference_raw(hlist_first_rcu(head)),\</span><br><span class="line">			typeof(*(pos)), member);			\</span><br><span class="line">		pos;							\</span><br><span class="line">		pos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\</span><br><span class="line">			&amp;(pos)-&gt;member)), typeof(*(pos)), member))</span><br></pre></td></tr></table></figure>
<p>那么是在哪里把挂载描述符加入到哈希表中，添加函数为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void __attach_mnt(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> mount *parent)</span><br><span class="line">&#123;</span><br><span class="line">	hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span><br><span class="line">			   m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));</span><br><span class="line">	list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount lock must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static void commit_tree(<span class="keyword">struct</span> mount *mnt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> mount *parent = mnt-&gt;mnt_parent;</span><br><span class="line">	<span class="keyword">struct</span> mount *m;</span><br><span class="line">	LIST_HEAD(head);</span><br><span class="line">	<span class="keyword">struct</span> mnt_namespace *n = parent-&gt;mnt_ns;</span><br><span class="line"></span><br><span class="line">	BUG_ON(parent == mnt);</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;head, &amp;mnt-&gt;mnt_list);</span><br><span class="line">	list_for_each_entry(m, &amp;head, mnt_list)</span><br><span class="line">		m-&gt;mnt_ns = n;</span><br><span class="line"></span><br><span class="line">	list_splice(&amp;head, n-&gt;list.prev);</span><br><span class="line"></span><br><span class="line">	n-&gt;mounts += n-&gt;pending_mounts;</span><br><span class="line">	n-&gt;pending_mounts = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//添加到哈希表中。</span></span><br><span class="line">	__attach_mnt(mnt, parent);</span><br><span class="line">	touch_mnt_namespace(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://woitaylor.github.io/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/" target="_blank" rel="noopener">Linux挂载文件系统</a> 里面介绍了系统调用 mount 的流程，其中会调用到 <code>commit_tree</code> 函数。下面是流程图：<br><img src="https://pic.superbed.cn/item/5d6f7d99451253d17824dc45.png" alt=""></p>
<h3 id="dentry-查找"><a href="#dentry-查找" class="headerlink" title="dentry 查找"></a>dentry 查找</h3><p>当对“.”和“..”处理完成后就直接返回进入下一个子路径循环了，但如果当前子路径不是“.”或“..”呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">int</span> walk_component(<span class="keyword">struct</span> nameidata * nd, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = lookup_fast(nd, &amp;path, &amp;inode, &amp;seq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">	<span class="comment">// lookup_fast 返回 1，也就是在内存中还没有读入对应的 dentry，</span></span><br><span class="line">	<span class="comment">//所以需要使用 lookup_slow 进行查找，注意此时已经退出了 rcu-walk 模式了。 	</span></span><br><span class="line">    err = lookup_slow(nd, &amp;path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    seq = <span class="number">0</span>;									<span class="comment">/* we are already out of RCU mode */</span></span><br><span class="line">    err = -ENOENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(path.dentry))</span><br><span class="line">      <span class="keyword">goto</span> out_path_put;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Kernel 中任何一个常用操作都会有两套以上的策略，其中一个是高效率的相对而言另一个就是系统开销比较大的。比如在上面的代码中就能直观的发现 Kernel 会首先尝试 fast（<code>lookup_fast</code>） ，如果失败了才会启动 slow（<code>lookup_slow</code>）。其实在我们当前的场景中不止这两种策略，别忘了在这里还有 rcu-walk 和 ref-walk，现在我们先简单介绍一下 Kernel 在这里进行 “路径行走” 的策略，让大家有一个感性认识，然后再进入这几个函数中进行理性分析。首先 Kernel 会在 rcu-walk 模式下进入 <code>lookup_fas</code>t 进行尝试，如果失败了那么就尝试就地转入 ref-walk，如果还是不行就回到 <code>do_filp_open</code> 从头开始。Kernel 在 ref-walk 模式下会首先在内存缓冲区查找相应的目标（lookup_fast），如果找不到就启动具体文件系统自己的 <code>lookup</code> 进行查找（<code>lookup_slow</code>）。注意，在 rcu-walk 模式下是不会进入 <code>lookup_slow</code> 的。如果这样都还找不到的话就一定是是出错了，那就报错返回吧，这时屏幕就会出现喜闻乐见的“No such file or directory”。<br>我们这就进入 <code>lookup_fast</code>，看看它到底有多快。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	It's more convoluted than I'd like it to be, but... it's still fairly</span></span><br><span class="line"><span class="comment"> *	small and for now I'd prefer to have fast path as straight as possible.</span></span><br><span class="line"><span class="comment"> *	It _is_ time-critical.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">int</span> lookup_fast(<span class="keyword">struct</span> nameidata * nd,</span><br><span class="line">	<span class="keyword">struct</span> path * path, <span class="keyword">struct</span> inode * *inode,</span><br><span class="line">	unsigned * seqp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> vfsmount * mnt = nd-&gt;path.mnt;</span><br><span class="line">	<span class="keyword">struct</span> dentry * dentry, *parent = nd-&gt;path.dentry;</span><br><span class="line">	<span class="keyword">int</span> need_reval = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Rename seqlock is not required here because in the off chance</span></span><br><span class="line"><span class="comment">	 * of a false negative due to a concurrent rename, we're going to</span></span><br><span class="line"><span class="comment">	 * do the non-racy lookup, below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">		unsigned seq;</span><br><span class="line">		<span class="keyword">bool</span> negative;</span><br><span class="line">      	<span class="comment">// 首先调用 __d_lookup_rcu 在内存中的某个散列表里通过字符串比较查找目标 dentry，</span></span><br><span class="line">      	<span class="comment">// 如果找到了就返回该 dentry</span></span><br><span class="line">		dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;seq);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 如果没有找到就跳转到 unlazy。在这里会使用 unlazy_walk 就地将查找模式切换到</span></span><br><span class="line">      	<span class="comment">// ref-walk 如果还不行就只好返回到 do_filp_open 从头来过。</span></span><br><span class="line">		<span class="keyword">if</span> (!dentry)</span><br><span class="line">			<span class="keyword">goto</span> unlazy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This sequence count validates that the inode matches</span></span><br><span class="line"><span class="comment">		 * the dentry name information from lookup.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*inode = d_backing_inode(dentry);</span><br><span class="line">		negative = d_is_negative(dentry);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 检查期间 dentry 有没有发生改变。</span></span><br><span class="line">		<span class="keyword">if</span> (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq))</span><br><span class="line">			<span class="keyword">return</span> - ECHILD;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This sequence count validates that the parent had no</span></span><br><span class="line"><span class="comment">		 * changes while we did the lookup of the dentry above.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The memory barrier in read_seqcount_begin of child is</span></span><br><span class="line"><span class="comment">		 *	enough, we can use __read_seqcount_retry here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 这个序列号用来验证这期间父目录的 dentry 没有发生改变，内存屏蔽在孩子调用的</span></span><br><span class="line">        <span class="comment">//  read_seqcount_begin 中已被设置了（也就是前面调用的 read_seqcount_begin）</span></span><br><span class="line">        <span class="comment">// 所以这里调用没有内存屏蔽的 __read_seqcount_retry 函数。</span></span><br><span class="line">		<span class="keyword">if</span> (__read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq))</span><br><span class="line">			<span class="keyword">return</span> - ECHILD;</span><br><span class="line"></span><br><span class="line">		*seqp = seq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某些文件系统需要进行有效性验证，比如网络文件系统，服务端的数据已经更新了，但是</span></span><br><span class="line">        <span class="comment">// 客户端保存的是以前的数据。一般来说本地文件系统不需要进行有效性验证，比如 EXT4 文件系统。</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE)) &#123;</span><br><span class="line">			status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line">            <span class="comment">// 有效性验证失败。</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(status &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 返回 -ECHILD 表示遇到了 rcu-walk 模式无法处理的问题。</span></span><br><span class="line">				<span class="keyword">if</span> (status != -ECHILD)</span><br><span class="line">					need_reval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">goto</span> unlazy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Note: do negative dentry check after revalidation in</span></span><br><span class="line"><span class="comment">		 * case that drops it.</span></span><br><span class="line"><span class="comment">		 * 在有效性验证后再次做 negative dentry 检测。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (negative)</span><br><span class="line">			<span class="keyword">return</span> - ENOENT;</span><br><span class="line"></span><br><span class="line">		path-&gt;mnt = mnt;</span><br><span class="line">		path-&gt;dentry = dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有可能当前目录是挂载点，或者自动挂载点等 “伪目标”，所以我们这里要跨过。</span></span><br><span class="line">		<span class="keyword">if</span> (likely(__follow_mount_rcu(nd, path, inode, seqp)))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跑到这里表示需要切换到 ref-walk 模式进行查找。</span></span><br><span class="line">unlazy:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlazy_walk(nd, dentry, seq))</span><br><span class="line">			<span class="keyword">return</span> - ECHILD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dentry = __d_lookup(parent, &amp;nd-&gt;last);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果还是没有找到 dentry，那么返回 1 ，接着在 walk_component 函数中进行 lookup_slow。</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dentry))</span><br><span class="line">		<span class="keyword">goto</span> need_lookup;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE) &amp;&amp; need_reval)</span><br><span class="line">		status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(status &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dput(dentry);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		d_invalidate(dentry);</span><br><span class="line">		dput(dentry);</span><br><span class="line">		<span class="keyword">goto</span> need_lookup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(d_is_negative(dentry))) &#123;</span><br><span class="line">		dput(dentry);</span><br><span class="line">		<span class="keyword">return</span> - ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	path-&gt;mnt = mnt;</span><br><span class="line">	path-&gt;dentry = dentry;</span><br><span class="line">		<span class="comment">// 处理按照某种方式管理的目录（自动挂载工具 autofs 管理这个目录的跳转，挂载点或自动挂载点。</span></span><br><span class="line">	err = follow_managed(path, nd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!err))</span><br><span class="line">		*inode = d_backing_inode(path-&gt;dentry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">need_lookup:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>__d_lookup_rcu</code> 在内存中的某个散列表里通过字符串比较查找目标 dentry，如果找到了就返回该 dentry；如果没找到就需要跳转到 unlazy 标号处，在这里会使用 <code>unlazy_walk</code> 就地将查找模式切换到 ref-walk，如果还不行就只好返回到 <code>do_filp_open</code> 从头来）。</p>
<p>如果顺利找到了目标 dentry 则还需要进行一系列的检查确保在我们做读取操作的期间没有人对这些结构进行改动。然后就是更新临时变量 path，为啥不更新 nd 呢？别忘了 nd 是很有脾气的，挂载点和符号链接人家都看不上，非真正目录不嫁。而这个时候还不知道这个目标是不是一个挂载点，如果是挂载点则还需要沿着被挂载的 mount 结构走到真正的目标上；退一步来说，就算这个目标不是挂载点，但它要是具备自动挂载特性呢；再退一步来说，它是不是符号链接我们也不知道，所以现在先不忙着更新 nd。紧接着就通过 <code>__follow_mount_rcu</code> 跨过挂载点这些“伪目标”，这个函数和上一篇里 <code>follow_dotdot_rcu</code> 的第二部分很相似我们就不深入进去了，有兴趣的同学结合代码自己研究一下就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if</span></span><br><span class="line"><span class="comment"> * we meet a managed dentry that would need blocking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">bool</span> __follow_mount_rcu(<span class="keyword">struct</span> nameidata * nd, <span class="keyword">struct</span> path * path,</span><br><span class="line">	<span class="keyword">struct</span> inode * *inode, unsigned * seqp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 和 follow_dotdot_rcu 一样开始死循环。</span></span><br><span class="line">	<span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">		<span class="keyword">struct</span> mount * mounted;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don't forget we might have a non-mountpoint managed dentry</span></span><br><span class="line"><span class="comment">		 * that wants to block transit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">     	<span class="comment">// 是否设置了 DCACHE_MANAGE_TRANSIT 标志，如果设置了，则调用 dentry 的 d_manage</span></span><br><span class="line">     	<span class="comment">// 函数来托管这个 dentry 的处理。</span></span><br><span class="line">		<span class="keyword">switch</span> (managed_dentry_rcu(path-&gt;dentry))</span><br><span class="line">		&#123;</span><br><span class="line">      		<span class="comment">// 如果调用者的路径查找处于 RCU 模式。这种模式下是不允许睡眠，所以</span></span><br><span class="line">      		<span class="comment">// 调用者被要求离开该函数并且返回 `-ECHILD`</span></span><br><span class="line">			<span class="keyword">case</span> - ECHILD:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      		<span class="comment">// d_manage 函数返回 `-EISDIR` 告诉当前路径查找忽略 `d_automount` 或者其他任何挂载。</span></span><br><span class="line">			<span class="keyword">case</span> - EISDIR:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      		<span class="comment">//返回 0表示让挂起的客户端继续执行</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!d_mountpoint(path-&gt;dentry))</span><br><span class="line">			<span class="keyword">return</span> ! (path-&gt;dentry-&gt;d_flags &amp; DCACHE_NEED_AUTOMOUNT);</span><br><span class="line"></span><br><span class="line">		mounted = __lookup_mnt(path-&gt;mnt, path-&gt;dentry);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!mounted)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		path-&gt;mnt = &amp;mounted-&gt;mnt;</span><br><span class="line">		path-&gt;dentry = mounted-&gt;mnt.mnt_root;</span><br><span class="line">		nd-&gt;flags |= LOOKUP_JUMPED;</span><br><span class="line">		*seqp = read_seqcount_begin(&amp;path-&gt;dentry-&gt;d_seq);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Update the inode too. We don't need to re-check the</span></span><br><span class="line"><span class="comment">		 * dentry sequence number here after this d_inode read,</span></span><br><span class="line"><span class="comment">		 * because a mount-point is always pinned.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*inode = path-&gt;dentry-&gt;d_inode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ! read_seqretry(&amp;mount_lock, nd-&gt;m_seq) &amp;&amp; ! (path-&gt;dentry-&gt;d_flags &amp; DCACHE_NEED_AUTOMOUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一切顺利返回 0，请参考上面 walk_component 的代码，如果返回 0 就表示在 rcu-walk 模式下是不会启动 lookup_slow 的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">int</span> lookup_fast(<span class="keyword">struct</span> nameidata * nd,</span><br><span class="line">	<span class="keyword">struct</span> path * path, <span class="keyword">struct</span> inode * *inode,</span><br><span class="line">	unsigned * seqp)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">//跑到这里表示需要切换到 ref-walk 模式进行查找。</span></span><br><span class="line">unlazy:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlazy_walk(nd, dentry, seq))</span><br><span class="line">			<span class="keyword">return</span> - ECHILD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dentry = __d_lookup(parent, &amp;nd-&gt;last);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是没有找到 dentry，表示内存中还没有读入这个目标，那么返回 1 。</span></span><br><span class="line">    <span class="comment">// 接着在 walk_component 函数中进行 lookup_slow。</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dentry))</span><br><span class="line">		<span class="keyword">goto</span> need_lookup;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE) &amp;&amp; need_reval)</span><br><span class="line">		status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(status &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dput(dentry);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		d_invalidate(dentry);</span><br><span class="line">		dput(dentry);</span><br><span class="line">		<span class="keyword">goto</span> need_lookup;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(d_is_negative(dentry))) &#123;</span><br><span class="line">		dput(dentry);</span><br><span class="line">		<span class="keyword">return</span> - ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	path-&gt;mnt = mnt;</span><br><span class="line">	path-&gt;dentry = dentry;</span><br><span class="line">    <span class="comment">// 处理按照某种方式管理的目录（自动挂载工具 autofs 管理这个目录的跳转，</span></span><br><span class="line">    <span class="comment">// 挂载点或自动挂载点）。</span></span><br><span class="line">	err = follow_managed(path, nd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!err))</span><br><span class="line">		*inode = d_backing_inode(path-&gt;dentry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">need_lookup:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合 <code>walk_component</code> 的代码来看，我们发现只有在 <code>lookup_fast</code> 返回值大于 0 的时候才会启动 <code>lookup_slow</code>，而在 <code>lookup_fast</code> 里面我们看到只有一种情况返回值会大于 0，那就是 dentry 为 NULL 的情况下会返回 1。也就是说启动 <code>lookup_slow</code> 的先决条件就是内存中还没有读入这个目标。接下来的代码已经切换到了 ref-walk 模式中，但其处理方式和 rcu-walk 差不多，结合 rcu-walk 部分的讲解自己研究一下吧。需要提一句的就是 <code>follow_managed</code>，这个函数会检查当前 dentry 是否是个挂载点，如果是就跟下去（的确和 rcu-walk 差不多，是吧），不过这个函数还会检查另外两个特性 <code>DCACHE_MANAGE_TRANSIT</code> 和 <code>DCACHE_NEED_AUTOMOUNT</code>，可以参考链接：<br><a href="https://woitaylor.github.io/2019/08/31/Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Linux虚拟文件系统</a><br><a href="https://woitaylor.github.io/2019/08/28/Linux-path_lookup%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" target="_blank" rel="noopener">Linux路径查找</a></p>
<p>接下来看看 look_show 是如何工作的，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fast lookup failed, do it the slow way */</span></span><br><span class="line">static <span class="keyword">int</span> lookup_slow(<span class="keyword">struct</span> nameidata * nd, <span class="keyword">struct</span> path * path)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> dentry * dentry, *parent;</span><br><span class="line">	parent = nd-&gt;path.dentry;</span><br><span class="line">	BUG_ON(nd-&gt;inode != parent-&gt;d_inode);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;parent-&gt;d_inode-&gt;i_mutex);</span><br><span class="line">	dentry = __lookup_hash(&amp;nd-&gt;last, parent, nd-&gt;flags);</span><br><span class="line">	mutex_unlock(&amp;parent-&gt;d_inode-&gt;i_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dentry);</span><br><span class="line"></span><br><span class="line">	path-&gt;mnt = nd-&gt;path.mnt;</span><br><span class="line">	path-&gt;dentry = dentry;</span><br><span class="line">	<span class="keyword">return</span> follow_managed(path, nd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里大家就一定会明白为什么是 slow 了，互斥锁（mutex）是有可能引起进程阻塞的，而在 <code>lookup_fast</code> 里面没有使用任何可能导致进程睡眠的操作，这将导致 <code>lookup_slow</code> 的效率远远低于 <code>lookup_fast</code>。还不仅仅如此，我们继续看看 <code>__lookup_hash</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">struct</span> dentry * __lookup_hash(<span class="keyword">struct</span> qstr * name,</span><br><span class="line">	<span class="keyword">struct</span> dentry * base, unsigned <span class="keyword">int</span> flags) &#123;</span><br><span class="line">	<span class="keyword">bool</span> need_lookup;</span><br><span class="line">	<span class="keyword">struct</span> dentry * dentry;</span><br><span class="line">	dentry = lookup_dcache(name, base, flags, &amp;need_lookup);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!need_lookup)</span><br><span class="line">		<span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lookup_real(base-&gt;d_inode, dentry, flags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This looks up the name in dcache, possibly revalidates the old dentry and</span></span><br><span class="line"><span class="comment"> * allocates a new one if not found or not valid.  In the need_lookup argument</span></span><br><span class="line"><span class="comment"> * returns whether i_op-&gt;lookup is necessary.</span></span><br><span class="line"><span class="comment"> * 在 decache 中查找 name 对应的 dentry。可能需要验证这个“老”的 dentry，如果没有发现或者这个</span></span><br><span class="line"><span class="comment"> * “老”的 dentry 已经无效了，那么需要分配一个新的 dentry。通过参数 need_lookup 来决定是否需要</span></span><br><span class="line"><span class="comment"> * 调用 i_op-&gt;lookup。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dir-&gt;d_inode-&gt;i_mutex must be held</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">struct</span> dentry * lookup_dcache(<span class="keyword">struct</span> qstr * name, <span class="keyword">struct</span> dentry * dir,</span><br><span class="line">	unsigned <span class="keyword">int</span> flags, <span class="keyword">bool</span> * need_lookup) &#123;</span><br><span class="line">	<span class="keyword">struct</span> dentry * dentry;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	*need_lookup = <span class="literal">false</span>;</span><br><span class="line">	dentry = d_lookup(dir, name);</span><br><span class="line">	<span class="comment">// 如果在 decahe 中找到 dentry。</span></span><br><span class="line">	<span class="keyword">if</span> (dentry) &#123;</span><br><span class="line">		<span class="comment">// 是否需要重新验证。</span></span><br><span class="line">		<span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE) &#123;</span><br><span class="line">			error = d_revalidate(dentry, flags);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(error &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					dput(dentry);</span><br><span class="line">					<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					d_invalidate(dentry);</span><br><span class="line">					dput(dentry);</span><br><span class="line">					dentry = NULL;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dentry) &#123;</span><br><span class="line">		<span class="comment">// 分配一个 dentry，这里只是分配了内存，还没有绑定 inode，</span></span><br><span class="line">		<span class="comment">// 所以该 dentry 为 negative dentry。</span></span><br><span class="line">		dentry = d_alloc(dir, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!dentry))</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">		<span class="comment">// need_lookup 设置为 true 之后将会调用 lookup_real。</span></span><br><span class="line">		*need_lookup = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call i_op-&gt;lookup on the dentry.  The dentry must be negative and</span></span><br><span class="line"><span class="comment"> * unhashed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dir-&gt;d_inode-&gt;i_mutex must be held</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">struct</span> dentry * lookup_real(<span class="keyword">struct</span> inode * dir, <span class="keyword">struct</span> dentry * dentry,</span><br><span class="line">	unsigned <span class="keyword">int</span> flags) &#123;</span><br><span class="line">	<span class="keyword">struct</span> dentry * old;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don't create child dentry for a dead directory. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(IS_DEADDIR(dir))) &#123;</span><br><span class="line">		dput(dentry);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	old = dir-&gt;i_op-&gt;lookup(dir, dentry, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old)) &#123;</span><br><span class="line">		dput(dentry);</span><br><span class="line">		dentry = old;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dentry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lookup: called when the VFS needs to look up an inode in a parent directory. The name to look for is found in the dentry. This method must call d_add() to insert the found inode into the dentry. The “i_count” field in the inode structure should be incremented. If the named inode does not exist a NULL inode should be inserted into the dentry (this is called a negative dentry). Returning an error code from this routine must only be done on a real error, otherwise creating inodes with system calls like create(2), mknod(2), mkdir(2) and so on will fail. If you wish to overload the dentry methods then you should initialise the “d_dop” field in the dentry; this is a pointer to a struct “dentry_operations”. This method is called with the directory inode semaphore held</p>
</blockquote>
<p>lookup：当 VFS 需要在父目录中查找 inode 时调用。从 dentry 中获取需要查找的名称。该方法必须调用 d_add() 将发现的 inode 插入到 dentry 中。在 inode 结构中，“i_count” 字段应该递增。如果命名的 inode 不存在，一个 NULL 的 inode应该插入到 dentry (这称为 negative dentry)。必须只在一个真正的错误发生时这个子程序才返回一个错误代码，否则就会用系统调用来创建 inodes, 比如 create(2)、mknod(2)、mkdir(2) 等等。如果您希望重载该 dentry 方法,那么您应该在 dentry 中初始化 “d_dop” 字段；这是一个指向 struct “dentry_operation” 的指针。该方法的调用需要获取该目录的 inode 信号量（i_lock）。</p>
<p>请先看 <code>dentry = lookup_dcache(name, base, flags, &amp;need_lookup);</code>，大家可能会奇怪：不是在内存中没找到才进来的吗，怎么这里又去内存中找一遍？别忘了，上一级函数使用了互斥锁，这将有可能导致进程睡眠，也就有可能恰好有人在我们睡觉的时候这个目标加载进了内存，所以这里需要检查一下，而且反正是在内存中查找，不会太费事的。要是真找到了呢，那就撞大运了，高高兴兴的返回吧，要还是没有就只好自己动手丰衣足食老老实实的启动 <code>lookup_real</code> ，从真正的文件系统上读取吧。<code>lookup_real</code> 我们就不深入进去了，在里面主要是调用了具体文件系统自己的 <code>lookup</code> 函数去完成工作，而这些函数很有可能会启动文件系统所在设备的驱动程序，从真正的设备上读取（例如硬盘）数据，所以就更慢了，这才是名副其实的 “lookup_slow”。<code>lookup_slow</code> 剩下的工作和 fast 差不多，这里就不重复了。接着看 <code>walk_component</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">int</span> walk_component(<span class="keyword">struct</span> nameidata * nd, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//这种情况处于解析链接最后一个分量，释放当前已解析完的符号链接。</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; WALK_PUT)</span><br><span class="line">    put_link(nd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 符号链接处理。</span></span><br><span class="line">  err = should_follow_link(nd, &amp;path, flags &amp; WALK_GET, inode, seq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(err))</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到这一步可以真正地更新 nd 结构了。</span></span><br><span class="line">  path_to_nameidata(&amp;path, nd);</span><br><span class="line">  nd-&gt;inode = inode;</span><br><span class="line">  nd-&gt;seq = seq;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out_path_put:</span><br><span class="line">  path_to_nameidata(&amp;path, nd);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当走到这里的时候 nd 还是指向父级目录，但 path 已经指向子目录项了，这时只需确定该目录项是一个正常的目录，就可以更新 nd 然后继续下一个子目录项（<code>path_to_nameidata</code>）。但如果真是一个符号链接呢？在 <code>should_follow_link</code> 函数中需要先切换到 ref-walk 模式，然后返回 1，让 <code>link_path_walk</code> 接着处理这个符号链接。问题来了，为什么要切换到 ref-walk 模式呢？这是因为在处理符号链接的时候需要调用具体文件系统自己的处理函数，而在这些函数里很有可能会因为申请系统资源导致的进程阻塞，我们知道 rcu-walk 期间是禁止阻塞的，所以在这里需要先退出 rcu-walk 模式，因为 rcu-walk 模式是不允许睡眠或者阻塞。<br>下一篇解释符号链接处理流程。</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LiangLiang.li</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://woitaylor.github.io.git/2019/09/04/Linxu-Open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AF%87%E4%B8%89/">https://woitaylor.github.io.git/2019/09/04/Linxu-Open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AF%87%E4%B8%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LiangLiang.li</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">文件系统</span>
                                </a>
                            
                                <a href="/tags/open/">
                                    <span class="chip bg-color">open</span>
                                </a>
                            
                                <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
                                    <span class="chip bg-color">系统调用</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/05/Linux-Open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AF%87%E5%9B%9B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="Linux-Open系统调用篇（四）">
                        
                        <span class="card-title">Linux-Open系统调用篇（四）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            符号链接处理123456789101112131415161718192021222324252627/* * Do we need to follow links? We _really_ want to be able * to do 
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-09-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                    Linux内核
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">文件系统</span>
                    </a>
                    
                    <a href="/tags/open/">
                        <span class="chip bg-color">open</span>
                    </a>
                    
                    <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
                        <span class="chip bg-color">系统调用</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8Bautofs/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="Linux文件系统之autofs">
                        
                        <span class="card-title">Linux文件系统之autofs</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            autofs - how it worksPurpose
The goal of autofs is to provide on-demand mounting and race free automatic unmounting of v
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-09-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux%E5%86%85%E6%A0%B8/" class="post-category">
                                    Linux内核
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">文件系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">LiangLiang.li</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
